<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>QuantumPropagators · QuantumControlBase.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://juliaquantumcontrol.github.io/QuantumControlBase.jl/quantumpropagators/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><script src="../../copy.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">QuantumControlBase.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>QuantumPropagators</a></li><li><a class="tocitem" href="../history/">History</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>QuantumPropagators</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>QuantumPropagators</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/master/docs/src/quantumpropagators.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="QuantumPropagators"><a class="docs-heading-anchor" href="#QuantumPropagators">QuantumPropagators</a><a id="QuantumPropagators-1"></a><a class="docs-heading-anchor-permalink" href="#QuantumPropagators" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="QuantumPropagators.initpropwrk-Tuple{Any, Any, Val{:auto}, Vararg{Any}}" href="#QuantumPropagators.initpropwrk-Tuple{Any, Any, Val{:auto}, Vararg{Any}}"><code>QuantumPropagators.initpropwrk</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Initialize a workspace for propagation.</p><pre><code class="language-julia hljs">wrk = initpropwrk(state, tlist, method=:auto, generator...; kwargs...)</code></pre><p>The resulting <code>wrk</code> can be passed to <a href="#QuantumPropagators.propagate-Tuple{Any, Any, Any}"><code>propagate</code></a> or <a href="#QuantumPropagators.propstep!-Tuple{Any, Any, Any, QuantumPropagators.Cheby.ChebyWrk}"><code>propstep!</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>state</code>: An exemplary state for the propagation (e.g., the initial state)</li><li><code>tlist</code>: The time grid over which <a href="#QuantumPropagators.propagate-Tuple{Any, Any, Any}"><code>propagate</code></a> will be called. Must include at least to points in order to determine the propagation time step to prepare. If the propagation will be over a <code>tlist</code> with a variable <code>dt</code>, the full <code>tlist</code> must be passed here.</li><li><code>generator</code>: An exemplary (non-time-dependent) dynamical generator. For full generality (if <code>method=:cheby</code>), the given <code>generator</code> should have a spectral range sufficiently large to encompass the entire propagation. If given multiple times, a spectral envelope enclosing all the generators will be determined automatically. In this case, you should pass the generators with the extremal values of all the controls.</li><li><code>method</code>: The propagation method to use. The default value of <code>:auto</code> attempts to choose the best method available, based on the properties of the given <code>state</code>, <code>tlist</code>, and <code>generator</code>. Alternative values are <code>:cheby</code> and <code>:newton</code>, and <code>:expprop</code>.</li><li><code>specrad_method</code>: for <code>method=:cheby</code>, method to use for estimating the  spectral radius, see <a href="@ref"><code>QuantumPropagators.SpectralRange.specrange</code></a>.  Defaults to <code>:auto</code>.</li><li><code>tolerance</code>: for <code>method=:cheby</code>, a tolerance factor for the estimated spectral radius. That is, Chebychev coefficients will be calculated for a spectral radius increased by the <code>tolerance</code> factor compared to the specral radius estimated for the <code>generator</code>.</li></ul><p>All other <code>kwargs</code> are filtered and passed to the contructor for returned workspace, e.g. <code>limit</code> for <code>method=:cheby</code> or <code>m_max</code> for <code>method=:newton</code>. For <code>method=:cheby</code>, they are also passed to <a href="@ref QuantumPropagators.SpectralRange.specrange"><code>specrange</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl.git#master/blob/0aa48955a046eae0e01e63a6e6a2de5230c388dc/src/propagate.jl#L5-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumPropagators.propagate-Tuple{Any, Any, Any}" href="#QuantumPropagators.propagate-Tuple{Any, Any, Any}"><code>QuantumPropagators.propagate</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Propagate a state over an entire time grid.</p><pre><code class="language-julia hljs">state_out = propagate(
    state, genfunc, tlist; method=:auto,
    backwards=false; storage=nothing, observables=(&lt;store state&gt;, ),
    hook=nothing, showprogress=false, control_parameters=nothing,
    in_place=true, kwargs...)</code></pre><p>propagates <code>state</code> over the time grid in <code>tlist</code>, using piecewise-constant dynamical generators (Hamiltonians or Liouvillians) determined by <code>genfunc</code>, and returns the resulting propagated state. The propagation is performed by calling <a href="#QuantumPropagators.propstep!-Tuple{Any, Any, Any, QuantumPropagators.Cheby.ChebyWrk}"><code>propstep!</code></a> for every interval in <code>tlist</code>, or <a href="#QuantumPropagators.propstep-Tuple{Any, Any, Any, QuantumPropagators.ExpProp.ExpPropWrk}"><code>propstep</code></a> if <code>in_place=false</code>.</p><p>For the i&#39;th time interval, <code>genfunc(tlist, i)</code> must return the generator for that time interval. Generally, when approximating a time-continuous dynamical generator as piecewise-constant on the time grid, it should be evaluated at the <em>midpoint</em> of the interval. A possible exception is the first and last interval, which may be better evaluated at <code>tlist[1]</code> and <code>tlist[end]</code> to ensure exact boundary conditions like control fields that are exactly zero.</p><p>In addition to the two positional parameters indicating the time interval, <code>genfunc</code> will also receive the <code>state</code> (the input state for the propagation step), <code>backwards</code>, <code>storage</code>, <code>observables</code>, <code>control_parameters</code>, and <code>init</code> as keyword arguments.</p><p>The <code>control_parameters</code> are an optional array of floats with parameters for <code>genfunc</code>. This is required when <code>propagate</code> is used in the context of automatic differentiation (AD). E.g., the <a href="https://fluxml.ai/Zygote.jl/">Zygote</a> framework can automatically calculate gradients of a function <code>control_parameters -&gt; J_T</code>, where <code>J_T</code> might be be a function of the overlap between a propagated state (returned by <code>propagate</code>) and a target state. Thus, the <code>control_parameters</code> must be <em>explicit</em> in <code>propagate</code>.  Outside of an AD context, <code>control_parameters</code> are not generally required: they can be implicit in <code>genfunc</code>.</p><p>The remaining keyword arguments may be used for unusual equations of motion beyond the standard Schrödinger or Liouville-von-Neumann equation, e.g. <code>state</code> would enter the <code>genfunc</code> for a Gross–Pitaevskii equation. For standard equations of motion that do not use the additional parameters, it is best to capture the keyword arguments to <code>genfunc</code> with a definition like</p><pre><code class="language-julia hljs">genfunc(tlist, i; kwargs...) = ...</code></pre><p>For valid propagation <code>method</code>s, see <a href="#QuantumPropagators.initpropwrk-Tuple{Any, Any, Val{:auto}, Vararg{Any}}"><code>initpropwrk</code></a>.</p><p>In general, there is no requirement that <code>tlist</code> has a constant time step, although some propagation methods (most notably <a href="@ref QuantumPropagators.Cheby.cheby!"><code>cheby!</code></a>) only support a uniform time grid.</p><p>If <code>storage</code> is given as an Array, it will be filled with data determined by the <code>observables</code>. The default &quot;observable&quot; results in the propagated states at every point in time being stored. The <code>storage</code> array should be created with <a href="@ref"><code>init_storage</code></a>. See its documentation for details.</p><p>The <code>storage</code> parameter may also be given as <code>true</code>, and a new storage array will be created internally with <a href="@ref"><code>init_storage</code></a> and returned instead of the propagated state:</p><pre><code class="language-julia hljs">data = propagate(
    state, genfunc, tlist; method=:auto
    backwards=false; storage=true, observables=observables,
    hook=nothing, showprogress=false, kwargs...)</code></pre><p>If <code>backwards</code> is <code>true</code>, the input state is assumed to be at time <code>tlist[end]</code>, and the propagation progresses backwards in time (with a negative time step <code>dt</code>). If <code>storage</code> is given, it will be filled back-to-front during the backwards propagation.</p><p>If <code>hook</code> is given as a callable, it will be called after each propagation step, as <code>hook(state, generator, tlist, i, wrk, observables)</code> where <code>i</code> is the index of the time interval on <code>tlist</code> covered by the propagation step (0 for the initial state, respectives <code>lastindex(tlist)</code> for the backward propagation).  The <code>hook</code> is called before calculating any observables. Example usage includes writing data to file, or modifying <code>state</code>, e.g., removing amplitude from the lowest and highest level to mitigate &quot;truncation error&quot;.</p><p>If <code>showprogress</code> is given as <code>true</code>, a progress bar will be shown for long-running propagationn. In order to customize the progress bar, <code>showprogress</code> may also be a function that receives <code>length(tlist)</code> and returns a <code>ProgressMeter.Progress</code> instance.</p><p>If <code>in_place=false</code> is given, the propagation avoids in-place operations by using <a href="#QuantumPropagators.propstep-Tuple{Any, Any, Any, QuantumPropagators.ExpProp.ExpPropWrk}"><code>propstep</code></a> instead of <a href="#QuantumPropagators.propstep!-Tuple{Any, Any, Any, QuantumPropagators.Cheby.ChebyWrk}"><code>propstep!</code></a>. This is often required in the context of automatic differentiation (AD), e.g., with <a href="https://fluxml.ai/Zygote.jl/">Zygote</a>. That is, use <code>in_place=false</code> if <code>propagate</code> is called inside a function to be passed to <code>Zygote.gradient</code>, <code>Zygote.pullback</code>, or a similar function. In and AD context, <code>storage</code> and <code>showprogress</code> should not be used.</p><p>The <code>propagate</code> routine returns the propagated state at <code>tlist[end]</code>, respectively <code>tlist[1]</code> if <code>backwards=true</code>, or a storage array with the stored states / observable data if <code>storage=true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl.git#master/blob/0aa48955a046eae0e01e63a6e6a2de5230c388dc/src/propagate.jl#L210-L312">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumPropagators.propstep!-Tuple{Any, Any, Any, QuantumPropagators.Cheby.ChebyWrk}" href="#QuantumPropagators.propstep!-Tuple{Any, Any, Any, QuantumPropagators.Cheby.ChebyWrk}"><code>QuantumPropagators.propstep!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Perform a single propagation step in-place.</p><pre><code class="language-julia hljs">propstep!(state, generator, dt, wrk; kwargs...)</code></pre><p>The propagation method is determined by <code>wrk</code>, see <a href="#QuantumPropagators.initpropwrk-Tuple{Any, Any, Val{:auto}, Vararg{Any}}"><code>initpropwrk</code></a>.</p><p>Generally, an in-place propagation will not be suitable for in the context of automatic differentiation.  See <a href="#QuantumPropagators.propagate-Tuple{Any, Any, Any}"><code>propagate</code></a> for a method that does not act in-place.</p><p>The <code>kwargs</code> are forwarded to the underlying method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl.git#master/blob/0aa48955a046eae0e01e63a6e6a2de5230c388dc/src/propagate.jl#L150-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumPropagators.propstep-Tuple{Any, Any, Any, QuantumPropagators.ExpProp.ExpPropWrk}" href="#QuantumPropagators.propstep-Tuple{Any, Any, Any, QuantumPropagators.ExpProp.ExpPropWrk}"><code>QuantumPropagators.propstep</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Perform a single propagation step and return the propagated <code>state</code>.</p><pre><code class="language-julia hljs">state_out = propstep(state, generator, dt, wrk; kwargs...)</code></pre><p>The propagation method is determined by <code>wrk</code>, see <a href="#QuantumPropagators.initpropwrk-Tuple{Any, Any, Val{:auto}, Vararg{Any}}"><code>initpropwrk</code></a>.</p><p>Unlike <a href="#QuantumPropagators.propstep!-Tuple{Any, Any, Any, QuantumPropagators.Cheby.ChebyWrk}"><code>propstep!</code></a>, this method does not act in place, which generally makes it more suitable for automatic differentiation. However, there may be a performance penalty associated with the additional memory allocations.</p><p>The <code>kwargs</code> are forwarded to the underlying method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumPropagators.jl.git#master/blob/0aa48955a046eae0e01e63a6e6a2de5230c388dc/src/propagate.jl#L177-L191">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../history/">History »</a><div class="flexbox-break"></div><p class="footer-message"><a href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl">QuantumControlBase.jl</a> v0.1.0+dev docs powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.12 on <span class="colophon-date" title="Wednesday 9 February 2022 02:20">Wednesday 9 February 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
