<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · QuantumControlBase.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://juliaquantumcontrol.github.io/QuantumControlBase.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>QuantumControlBase.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Reference"><span>Reference</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="QuantumControlBase"><a class="docs-heading-anchor" href="#QuantumControlBase">QuantumControlBase</a><a id="QuantumControlBase-1"></a><a class="docs-heading-anchor-permalink" href="#QuantumControlBase" title="Permalink"></a></h1><p>The <a href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl">QuantumControlBase</a> package provides methods the are useful to multiple packages within the <a href="https://github.com/juliaquantumcontrol">JuliaQuantumControl</a> organization.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>All user-facing methods defined here are exposed in the main <a href="https://juliaquantumcontrol.github.io/QuantumControl.jl/">QuantumControl</a> package, so please see <a href="https://juliaquantumcontrol.github.io/QuantumControl.jl/">its documentation</a> for information on the usage of these methods in a larger context.</p></div></div><p><span>$\gdef\tgt{\text{tgt}}$</span> <span>$\gdef\tr{\operatorname{tr}}$</span> <span>$\gdef\Re{\operatorname{Re}}$</span> <span>$\gdef\Im{\operatorname{Im}}$</span></p><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#QuantumControlBase.ControlProblem"><code>QuantumControlBase.ControlProblem</code></a></li><li><a href="#QuantumControlBase.Objective"><code>QuantumControlBase.Objective</code></a></li><li><a href="#Base.adjoint-Tuple{Objective}"><code>Base.adjoint</code></a></li><li><a href="#QuantumControlBase.chain_infohooks-Tuple"><code>QuantumControlBase.chain_infohooks</code></a></li><li><a href="#QuantumControlBase.get_control_deriv-Tuple{Function, Any}"><code>QuantumControlBase.get_control_deriv</code></a></li><li><a href="#QuantumControlBase.get_control_deriv-Tuple{Tuple, Any}"><code>QuantumControlBase.get_control_deriv</code></a></li><li><a href="#QuantumControlBase.get_control_derivs-Tuple{Any, Any}"><code>QuantumControlBase.get_control_derivs</code></a></li><li><a href="#QuantumControlBase.make_chi-Tuple{Any, Any}"><code>QuantumControlBase.make_chi</code></a></li><li><a href="#QuantumControlBase.make_grad_J_a-Tuple{Any, Any}"><code>QuantumControlBase.make_grad_J_a</code></a></li><li><a href="#QuantumControlBase.optimize-Tuple{ControlProblem}"><code>QuantumControlBase.optimize</code></a></li><li><a href="#QuantumControlBase.propagate_objective-Tuple{Any, Any}"><code>QuantumControlBase.propagate_objective</code></a></li><li><a href="#QuantumControlBase.propagate_objectives-Tuple{Any, Any}"><code>QuantumControlBase.propagate_objectives</code></a></li><li><a href="#QuantumControlBase.set_atexit_save_optimization-Tuple{Any, Any}"><code>QuantumControlBase.set_atexit_save_optimization</code></a></li><li><a href="#QuantumPropagators.Controls.get_controls-Tuple{Vector{&lt;:Objective}}"><code>QuantumPropagators.Controls.get_controls</code></a></li><li><a href="#QuantumPropagators.Controls.get_controls-Tuple{ControlProblem}"><code>QuantumPropagators.Controls.get_controls</code></a></li><li><a href="#QuantumPropagators.Controls.substitute-Tuple{Objective, Any}"><code>QuantumPropagators.Controls.substitute</code></a></li><li><a href="#QuantumControlBase.@threadsif-Tuple{Any, Any}"><code>QuantumControlBase.@threadsif</code></a></li></ul><h2 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.ControlProblem" href="#QuantumControlBase.ControlProblem"><code>QuantumControlBase.ControlProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A full control problem with multiple objectives.</p><pre><code class="language-julia hljs">ControlProblem(;
   objectives,
   tlist,
   kwargs...
)</code></pre><p>Note that the control problem can only be instantiated via keyword arguments.</p><p>The <code>objectives</code> are a list of <a href="#QuantumControlBase.Objective"><code>Objective</code></a> instances, each defining an initial state and a dynamical generator for the evolution of that state. Usually, the objective will also include a target state (see <a href="#QuantumControlBase.Objective"><code>Objective</code></a>) and possibly a weight.</p><p>The <code>tlist</code> is the time grid on which the time evolution of the initial states of each objective should be propagated.</p><p>The remaining <code>kwargs</code> are keyword arguments that are passed directly to the optimal control method. These typically include e.g. the optimization functional.</p><p>The control problem is solved by finding a set of controls that simultaneously fulfill all objectives.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/4e9d97bfb975410cc13c463482e3349fb0397a51/src/objectives.jl#L129-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.Objective" href="#QuantumControlBase.Objective"><code>QuantumControlBase.Objective</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Optimization objective.</p><pre><code class="language-julia hljs">Objective(;
    initial_state,
    generator,
    target_state=nothing,
    weight=1.0,
    kwargs...
)</code></pre><p>describes an optimization objective that is tracked by the time evolution of the given <code>initial_state</code> under the given <code>generator</code>, e.g., a time-dependent Hamiltonian or Liouvillian. Each objective represents a single propagated state on which an optimization functional may depend.</p><p>The most common control problems in quantum control (state-to-state, gate optimization) require that the <code>initial_state</code> evolves into a <code>target_state</code>, which should be given as a keyword argument.</p><p>An optimization functional usually depends on <em>multiple</em> forward-propagated states (i.e., multiple <code>objectives</code>). Sometimes, it is useful to weight the contributions of different <code>objectives</code> relative to each other, see, e.g., Goerz <em>et al</em>., New J. Phys. 16, 055012 (2014). To this end, a <code>weight</code> can be attached to each <code>Objective</code> as an optional keyword argument.</p><p>Any other keyword arguments are available to a custom functional as properties of the <code>Objective</code> .</p><p>Note that the <code>Objective</code> can only be instantiated via keyword arguments, with <code>initial_state</code> and <code>generator</code> being the only two mandatory keyword arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/4e9d97bfb975410cc13c463482e3349fb0397a51/src/objectives.jl#L10-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.adjoint-Tuple{Objective}" href="#Base.adjoint-Tuple{Objective}"><code>Base.adjoint</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct the adjoint of an optimization objective.</p><pre><code class="language-julia hljs">adjoint(objective)</code></pre><p>Adjoint of a control objective. The adjoint objective contains the adjoint of the dynamical generator <code>obj.generator</code>. All other fields contain a copy of the original field value.</p><p>The primary purpose of this adjoint is to facilitate the backward propagation under the adjoint generator that is central to gradient-based optimization methods such as GRAPE and Krotov&#39;s method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/4e9d97bfb975410cc13c463482e3349fb0397a51/src/objectives.jl#L213-L227">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.chain_infohooks-Tuple" href="#QuantumControlBase.chain_infohooks-Tuple"><code>QuantumControlBase.chain_infohooks</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Combine multiple <code>info_hook</code> functions.</p><pre><code class="language-julia hljs">chain_infohooks(funcs...)</code></pre><p>combines <code>funcs</code> into a single Function that can be passes as <code>info_hook</code> to <a href="#QuantumControlBase.ControlProblem"><code>ControlProblem</code></a> or any <code>optimize</code>-function.</p><p>Each function in <code>func</code> must be a suitable <code>info_hook</code> by itself. This means that it should receive the optimization workspace object as its first positional parameter, then positional parameters specific to the optimization method, and then an arbitrary number of data parameters. It must return either <code>nothing</code> or a tuple of &quot;info&quot; objects (which will end up in the <code>records</code> field of the optimization result).</p><p>When chaining infohooks, the <code>funcs</code> will be called in series, and the &quot;info&quot; objects will be accumulated into a single result tuple. The combined results from previous <code>funcs</code> will be given to the subsequent <code>funcs</code> as data parameters. This allows for the infohooks in the chain to communicate.</p><p>The chain will return the final combined result tuple, or <code>nothing</code> if all <code>funcs</code> return <code>nothing</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>When instantiating a <a href="#QuantumControlBase.ControlProblem"><code>ControlProblem</code></a>, any <code>info_hook</code> that is a tuple will be automatically processed with <code>chain_infohooks</code>. Thus, <code>chain_infohooks</code> rarely has to be invoked manually.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/4e9d97bfb975410cc13c463482e3349fb0397a51/src/infohook.jl#L2-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.get_control_deriv-Tuple{Function, Any}" href="#QuantumControlBase.get_control_deriv-Tuple{Function, Any}"><code>QuantumControlBase.get_control_deriv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">a = get_control_deriv(ampl, control)</code></pre><p>returns the derivative <span>$∂a_l(t)/∂ϵ_{l&#39;}(t)$</span> of the given amplitude <span>$a_l(\{ϵ_{l&#39;&#39;}(t)\}, t)$</span> with respect to the given control <span>$ϵ_{l&#39;}(t)$</span>. For &quot;trivial&quot; amplitudes, where <span>$a_l(t) ≡ ϵ_l(t)$</span>, the result with be either <code>1.0</code> or <code>0.0</code> (depending on whether <code>ampl ≡ control</code>). For non-trivial amplitudes, the result may be another amplitude that depends on the controls and potentially on time, but can be evaluated to a constant with <a href="quantumpropagators/#QuantumPropagators.Controls.evaluate-Tuple{Any, Vararg{Any}}"><code>evaluate</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/4e9d97bfb975410cc13c463482e3349fb0397a51/src/derivs.jl#L79-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.get_control_deriv-Tuple{Tuple, Any}" href="#QuantumControlBase.get_control_deriv-Tuple{Tuple, Any}"><code>QuantumControlBase.get_control_deriv</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get the derivative of the generator <span>$G$</span> w.r.t. the control <span>$ϵ(t)$</span>.</p><pre><code class="language-julia hljs">μ  = get_control_deriv(generator, control)</code></pre><p>returns <code>nothing</code> if the <code>generator</code> (Hamiltonian or Liouvillian) does not depend on <code>control</code>, or generator</p><p class="math-container">\[μ = \frac{∂G}{∂ϵ(t)}\]</p><p>otherwise. For linear control terms, <code>μ</code> will be a static operator, e.g. an <code>AbstractMatrix</code> or an <a href="quantumpropagators/#QuantumPropagators.Generators.Operator"><code>Operator</code></a>. For non-linear controls, <code>μ</code> will be time-dependent, e.g. a <a href="quantumpropagators/#QuantumPropagators.Generators.Generator"><code>Generator</code></a>. In either case, <a href="quantumpropagators/#QuantumPropagators.Controls.evaluate-Tuple{Any, Vararg{Any}}"><code>evaluate</code></a> should be used to evaluate <code>μ</code> into a constant operator for particular values of the controls and a particular point in time.</p><p>For constant generators, e.g. an <a href="quantumpropagators/#QuantumPropagators.Generators.Operator"><code>Operator</code></a>, the result is always <code>nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/4e9d97bfb975410cc13c463482e3349fb0397a51/src/derivs.jl#L29-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.get_control_derivs-Tuple{Any, Any}" href="#QuantumControlBase.get_control_derivs-Tuple{Any, Any}"><code>QuantumControlBase.get_control_derivs</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get a vector of the derivatives of <code>generator</code> w.r.t. each control.</p><pre><code class="language-julia hljs">get_control_derivs(generator, controls)</code></pre><p>return as vector containing the derivative of <code>generator</code> with respect to each control in <code>controls</code>. The elements of the vector are either <code>nothing</code> if <code>generator</code> does not depend on that particular control, or a function <code>μ(α)</code> that evaluates the derivative for a particular value of the control, see <a href="#QuantumControlBase.get_control_deriv-Tuple{Function, Any}"><code>get_control_deriv</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/4e9d97bfb975410cc13c463482e3349fb0397a51/src/derivs.jl#L5-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.make_chi-Tuple{Any, Any}" href="#QuantumControlBase.make_chi-Tuple{Any, Any}"><code>QuantumControlBase.make_chi</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return a function that evaluates <span>$|χ_k⟩ = -∂J_T/∂⟨ϕ_k|$</span>.</p><pre><code class="language-julia hljs">chi! = make_chi(
    J_T,
    objectives;
    force_zygote=false,
    via=(any(isnothing(obj.target_state) for obj in objectives) ? :phi : :tau),
    use_finite_differences=false
)</code></pre><p>creates a function <code>chi!(χ, ϕ, objectives; τ)</code> that sets the k&#39;th element of <code>χ</code> to <span>$|χ_k⟩ = -∂J_T/∂⟨ϕ_k|$</span>, where <span>$|ϕ_k⟩$</span> is the k&#39;th element of <code>ϕ</code>. These are the states used as the boundary condition for the backward propagation propagation in Krotov&#39;s method and GRAPE. Each <span>$|χₖ⟩$</span> is defined as a matrix calculus <a href="https://www.ekinakyurek.me/complex-derivatives-wirtinger/">Wirtinger derivative</a>,</p><p class="math-container">\[|χ_k(T)⟩ = -\frac{∂J_T}{∂⟨ϕ_k|} = -\frac{1}{2} ∇_{ϕ_k} J_T\,;\qquad
∇_{ϕ_k} J_T ≡ \frac{∂J_T}{\Re[ϕ_k]} + i \frac{∂J_T}{\Im[ϕ_k]}\,.\]</p><p>The function <code>J_T</code> must take a vector of states <code>ϕ</code> and a vector of <code>objectives</code> as positional parameters, and a vector <code>τ</code> as a keyword argument, see e.g. <code>J_T_sm</code>). If all objectives define a <code>target_state</code>, then <code>τ</code> will be the overlap of the states <code>ϕ</code> with those target states. The functional <code>J_T</code> may or may not use those overlaps.  Likewise, the resulting <code>chi!</code> may or may not use the keyword parameter <code>τ</code>.</p><p>For functionals where <span>$-∂J_T/∂⟨ϕ_k|$</span> is known analytically, that analytic derivative will be returned, e.g.,</p><ul><li><code>J_T_sm</code> → <code>chi_sm!</code>,</li><li><code>J_T_re</code> → <code>chi_re!</code>,</li><li><code>J_T_ss</code> → <code>chi_ss!</code>.</li></ul><p>Otherwise, or if <code>force_zygote=true</code> or <code>use_finite_differences=true</code>, the derivative to calculate <span>$|χ_k⟩$</span> will be evaluated automatically, via automatic differentiation with Zygote, or via finite differences (which primarily serves for testing the Zygote gradient).</p><p>When evaluating <span>$|χ_k⟩$</span> automatically, if <code>via=:phi</code> is given , <span>$|χ_k(T)⟩$</span> is calculated directly as defined a above from the gradient with respect to the states <span>$\{|ϕ_k(T)⟩\}$</span>. The resulting function <code>chi!</code> ignores any passed <code>τ</code> keyword argument.</p><p>If <code>via=:tau</code> is given instead, the functional <span>$J_T$</span> is considered a function of overlaps <span>$τ_k = ⟨ϕ_k^\tgt|ϕ_k(T)⟩$</span>. This requires that all <code>objectives</code> define a <code>target_state</code> and that <code>J_T</code> calculates the value of the functional solely based on the values of <code>τ</code> passed as a keyword argument.  With only the complex conjugate <span>$τ̄_k = ⟨ϕ_k(T)|ϕ_k^\tgt⟩$</span> having an explicit dependency on <span>$⟨ϕ_k(T)|$</span>,  the chain rule in this case is</p><p class="math-container">\[|χ_k(T)⟩
= -\frac{∂J_T}{∂⟨ϕ_k|}
= -\left(
    \frac{∂J_T}{∂τ̄_k}
    \frac{∂τ̄_k}{∂⟨ϕ_k|}
  \right)
= - \frac{1}{2} (∇_{τ_k} J_T) |ϕ_k^\tgt⟩\,.\]</p><p>Again, we have used the definition of the Wirtinger derivatives,</p><p class="math-container">\[\begin{align*}
    \frac{∂J_T}{∂τ_k}
    &amp;≡ \frac{1}{2}\left(
        \frac{∂ J_T}{∂ \Re[τ_k]}
        - i \frac{∂ J_T}{∂ \Im[τ_k]}
    \right)\,,\\
    \frac{∂J_T}{∂τ̄_k}
    &amp;≡ \frac{1}{2}\left(
        \frac{∂ J_T}{∂ \Re[τ_k]}
        + i \frac{∂ J_T}{∂ \Im[τ_k]}
    \right)\,,
\end{align*}\]</p><p>and the definition of the Zygote gradient with respect to a complex scalar,</p><p class="math-container">\[∇_{τ_k} J_T = \left(
    \frac{∂ J_T}{∂ \Re[τ_k]}
    + i \frac{∂ J_T}{∂ \Im[τ_k]}
\right)\,.\]</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>In order to extend <code>make_chi</code> with an analytic implementation for a new <code>J_T</code> function, define a new method <code>make_analytic_chi</code> like so:</p><pre><code class="language-julia hljs">make_analytic_chi(::typeof(J_T_sm), objectives) = chi_sm!</code></pre><p>which links <code>make_chi</code> for <code>J_T_sm</code> to <code>chi_sm!</code>.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Zygote is notorious for being buggy (silently returning incorrect gradients). Always test automatic derivatives against finite differences and/or other automatic differentiation frameworks.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/4e9d97bfb975410cc13c463482e3349fb0397a51/src/functionals.jl#L16-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.make_grad_J_a-Tuple{Any, Any}" href="#QuantumControlBase.make_grad_J_a-Tuple{Any, Any}"><code>QuantumControlBase.make_grad_J_a</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return a function to evaluate <span>$∂J_a/∂ϵ_{ln}$</span> for a pulse value running cost.</p><pre><code class="language-julia hljs">grad_J_a! = make_grad_J_a(
    J_a,
    tlist;
    force_zygote=false,
    use_finite_differences=false
)</code></pre><p>returns a function so that <code>grad_J_a!(∇J_a, pulsevals, tlist)</code> sets <span>$∂J_a/∂ϵ_{ln}$</span> as the elements of the (vectorized) <code>∇J_a</code>. The function <code>J_a</code> must have the interface <code>J_a(pulsevals, tlist)</code>, see, e.g., <code>J_a_fluence</code>.</p><p>If <code>force_zygote=true</code>, automatic differentiation with Zygote will be used to calculate the derivative.</p><p>If <code>use_finite_differences=true</code>, the derivative will be calculated via finite differences. This may be used to verify Zygote gradients.</p><p>By default, for functionals <code>J_a</code> that have a known analytic derivative, that analytic derivative will be used. For unknown functions, the derivative will be calculated via Zygote.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>In order to extend <code>make_grad_J_a</code> with an analytic implementation for a new <code>J_a</code> function, define a new method <code>make_analytic_grad_J_a</code> like so:</p><pre><code class="language-julia hljs">make_analytic_grad_J_a(::typeof(J_a_fluence), tlist) = grad_J_a_fluence!</code></pre><p>which links <code>make_grad_J_a</code> for <code>J_a_fluence</code> to <code>grad_J_a_fluence!</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/4e9d97bfb975410cc13c463482e3349fb0397a51/src/functionals.jl#L216-L253">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.optimize-Tuple{ControlProblem}" href="#QuantumControlBase.optimize-Tuple{ControlProblem}"><code>QuantumControlBase.optimize</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Optimize a quantum control problem.</p><pre><code class="language-julia hljs">result = optimize(problem; method=&lt;method&gt;, kwargs...)</code></pre><p>optimizes towards a solution of given <a href="#QuantumControlBase.ControlProblem"><code>problem</code></a> with the given optimization <code>method</code>. Any keyword argument temporarily overrides the corresponding keyword argument in <code>problem</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/4e9d97bfb975410cc13c463482e3349fb0397a51/src/optimize.jl#L3-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.propagate_objective-Tuple{Any, Any}" href="#QuantumControlBase.propagate_objective-Tuple{Any, Any}"><code>QuantumControlBase.propagate_objective</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Propagate with the dynamical generator of a control objective.</p><pre><code class="language-julia hljs">propagate_objective(obj, tlist; method=:auto, initial_state=obj.initial_state,
                    kwargs...)</code></pre><p>propagates <code>initial_state</code> under the dynamics described by <code>obj.generator</code>.</p><p>If <code>obj</code> has a property/field <code>prop_method</code> or <code>fw_prop_method</code>, its value will be used as the default for <code>method</code> instead of :auto. An explicit keyword argument for <code>method</code> always overrides the default.</p><p>All other <code>kwargs</code> are forwarded to the underlying <a href="quantumpropagators/#QuantumPropagators.propagate-Tuple{Any, Any, Any}"><code>QuantumPropagators.propagate</code></a> method for <code>obj.initial_state</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/4e9d97bfb975410cc13c463482e3349fb0397a51/src/propagate.jl#L31-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.propagate_objectives-Tuple{Any, Any}" href="#QuantumControlBase.propagate_objectives-Tuple{Any, Any}"><code>QuantumControlBase.propagate_objectives</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Propagate multiple objectives in parallel.</p><pre><code class="language-julia hljs">result = propagate_objectives(objectives, tlist; use_threads=true, kwargs...)</code></pre><p>runs <a href="#QuantumControlBase.propagate_objective-Tuple{Any, Any}"><code>propagate_objective</code></a> for every objective in <code>objectives</code>, collects and returns a vector of results. The propagation happens in parallel if <code>use_threads=true</code> (default). All keyword parameters are passed to <a href="#QuantumControlBase.propagate_objective-Tuple{Any, Any}"><code>propagate_objective</code></a>, except that if <code>initial_state</code> is given, it must be a vector of initial states, one for each objective. Likewise, to pass pre-allocated storage arrays to <code>storage</code>, a vector of storage arrays must be passed. A simple <code>storage=true</code> will still work to return a vector of storage results.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/4e9d97bfb975410cc13c463482e3349fb0397a51/src/propagate.jl#L71-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.set_atexit_save_optimization-Tuple{Any, Any}" href="#QuantumControlBase.set_atexit_save_optimization-Tuple{Any, Any}"><code>QuantumControlBase.set_atexit_save_optimization</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Register a callback to dump a running optimization to disk on unexpected exit.</p><p>A long-running optimization routine may use</p><pre><code class="language-julia hljs">if !isnothing(atexit_filename)
    set_atexit_save_optimization(
        atexit_filename, result; msg_property=:messsage, msg=&quot;Abort: ATEXIT&quot;
    )
    # ...
    popfirst!(Base.atexit_hooks)  # remove callback
end</code></pre><p>to register a callback that writes the given <code>result</code> object to the given <code>filename</code> in JLD2 format in the event that the program terminates unexpectedly. The idea is to avoid data loss if the user presses <code>CTRL-C</code> in a non-interactive program (<code>SIGINT</code>), or if the process receives a <code>SIGTERM</code> from an HPC scheduler because the process has reached its allocated runtime limit. Note that the callback cannot protect against data loss in all possible scenarios, e.g., a <code>SIGKILL</code> will terminate the program without giving the callback a chance to run (as will yanking the power cord).</p><p>As in the above example, the optimization routine should make <code>set_atexit_save_optimization</code> conditional on an <code>atexit_filename</code> keyword argument, which is what <code>QuantumControl.@optimize_or_load</code> will pass to the optimization routine. The optimization routine must remove the callback from <code>Base.atexit_hooks</code> when it exits normally. Note that in an interactive context, <code>CTRL-C</code> will throw an <code>InterruptException</code>, but not cause a shutdown. Optimization routines that want to prevent data loss in this situation should handle the <code>InterruptException</code> and return <code>result</code>, in addition to using <code>set_atexit_save_optimization</code>.</p><p>If <code>msg_property</code> is not <code>nothing</code>, the given <code>msg</code> string will be stored in the corresponding property of the (mutable) <code>result</code> object before it is written out.</p><p>The resulting JLD2 file is compatible with <code>QuantumControl.load_optimization</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/4e9d97bfb975410cc13c463482e3349fb0397a51/src/atexit.jl#L3-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumPropagators.Controls.get_controls-Tuple{ControlProblem}" href="#QuantumPropagators.Controls.get_controls-Tuple{ControlProblem}"><code>QuantumPropagators.Controls.get_controls</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">controls = get_controls(problem)</code></pre><p>extracts the controls from <code>problem.objectives</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/4e9d97bfb975410cc13c463482e3349fb0397a51/src/objectives.jl#L262-L268">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumPropagators.Controls.get_controls-Tuple{Vector{&lt;:Objective}}" href="#QuantumPropagators.Controls.get_controls-Tuple{Vector{&lt;:Objective}}"><code>QuantumPropagators.Controls.get_controls</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">controls = get_controls(objectives)</code></pre><p>extracts the controls from a list of objectives (i.e., from each objective&#39;s <code>generator</code>). Controls that occur multiple times in the different objectives will occur only once in the result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/4e9d97bfb975410cc13c463482e3349fb0397a51/src/objectives.jl#L237-L245">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumPropagators.Controls.substitute-Tuple{Objective, Any}" href="#QuantumPropagators.Controls.substitute-Tuple{Objective, Any}"><code>QuantumPropagators.Controls.substitute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">objective = substitute(objective::Objective, replacements)
objectives = substitute(objectives::Vector{Objective}, replacements)</code></pre><p>recursively substitutes the <code>initial_state</code>, <code>generator</code>, and <code>target_state</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/4e9d97bfb975410cc13c463482e3349fb0397a51/src/objectives.jl#L103-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.@threadsif-Tuple{Any, Any}" href="#QuantumControlBase.@threadsif-Tuple{Any, Any}"><code>QuantumControlBase.@threadsif</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Conditionally apply multi-threading to <code>for</code> loops.</p><p>This is a variation on <code>Base.Threads.@threads</code> that adds a run-time boolean flag to enable or disable threading. It is intended for <em>internal use</em> in packages building on <code>QuantumControlBase</code>.</p><p>Usage:</p><pre><code class="language-julia hljs">using QuantumControlBase: @threadsif

function optimize(objectives; use_threads=true)
    @threadsif use_threads for k = 1:length(objectives)
    # ...
    end
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl/blob/4e9d97bfb975410cc13c463482e3349fb0397a51/src/conditionalthreads.jl#L7-L25">source</a></section></article></article><nav class="docs-footer"><p class="footer-message"><a href="https://github.com/JuliaQuantumControl/QuantumControlBase.jl">QuantumControlBase.jl</a> v0.8.2+dev docs powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Saturday 13 May 2023 21:48">Saturday 13 May 2023</span>. Using Julia version 1.9.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
