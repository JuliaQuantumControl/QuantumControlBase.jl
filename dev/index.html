<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · QuantumControlBase.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://QuantumControl-jl.github.io/QuantumControlBase.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>QuantumControlBase.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/quantumcontrol-jl/QuantumControlBase.jl/blob/master/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="QuantumControlBase"><a class="docs-heading-anchor" href="#QuantumControlBase">QuantumControlBase</a><a id="QuantumControlBase-1"></a><a class="docs-heading-anchor-permalink" href="#QuantumControlBase" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/quantumcontrol-jl/QuantumControlBase.jl">QuantumControlBase</a>.</p><ul><li><a href="#QuantumControlBase.AbstractControlObjective"><code>QuantumControlBase.AbstractControlObjective</code></a></li><li><a href="#QuantumControlBase.ControlProblem"><code>QuantumControlBase.ControlProblem</code></a></li><li><a href="#QuantumControlBase.Objective"><code>QuantumControlBase.Objective</code></a></li><li><a href="#QuantumControlBase.WeightedObjective"><code>QuantumControlBase.WeightedObjective</code></a></li><li><a href="#Base.adjoint-Tuple{Objective}"><code>Base.adjoint</code></a></li><li><a href="#QuantumControlBase.blackman-Tuple{Any, Any, Any}"><code>QuantumControlBase.blackman</code></a></li><li><a href="#QuantumControlBase.box-Tuple{Any, Any, Any}"><code>QuantumControlBase.box</code></a></li><li><a href="#QuantumControlBase.discretize-Tuple{Function, Any}"><code>QuantumControlBase.discretize</code></a></li><li><a href="#QuantumControlBase.discretize_on_midpoints-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:Function"><code>QuantumControlBase.discretize_on_midpoints</code></a></li><li><a href="#QuantumControlBase.flattop-Tuple{Any}"><code>QuantumControlBase.flattop</code></a></li><li><a href="#QuantumControlBase.getcontrols-Tuple{Tuple}"><code>QuantumControlBase.getcontrols</code></a></li><li><a href="#QuantumControlBase.initobjpropwrk-Tuple{Objective, Any, Val}"><code>QuantumControlBase.initobjpropwrk</code></a></li><li><a href="#QuantumControlBase.liouvillian"><code>QuantumControlBase.liouvillian</code></a></li><li><a href="#QuantumControlBase.setcontrolvals-Union{Tuple{D}, Tuple{Tuple, D}} where D&lt;:AbstractDict"><code>QuantumControlBase.setcontrolvals</code></a></li><li><a href="#QuantumControlBase.setcontrolvals!-Union{Tuple{D}, Tuple{Any, Tuple, D}} where D&lt;:AbstractDict"><code>QuantumControlBase.setcontrolvals!</code></a></li><li><a href="#QuantumPropagators.propagate-Tuple{Objective, Any}"><code>QuantumPropagators.propagate</code></a></li><li><a href="#QuantumControlBase.ConditionalThreads.@threadsif-Tuple{Any, Any}"><code>QuantumControlBase.ConditionalThreads.@threadsif</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.AbstractControlObjective" href="#QuantumControlBase.AbstractControlObjective"><code>QuantumControlBase.AbstractControlObjective</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Base class for a single optimization objective.</p><p>All objectives must have a field <code>initial_state</code> and a field <code>generator</code>, at minimum.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quantumcontrol-jl/QuantumControlBase.jl/blob/46bc29b4b57a47d47bf46d42af1235952fa890fb/src/controlproblem.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.ControlProblem" href="#QuantumControlBase.ControlProblem"><code>QuantumControlBase.ControlProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A full control problem with multiple objectives.</p><pre><code class="language-julia hljs">ControlProblem(
   objectives=&lt;list of objectives&gt;,
   pulse_options=&lt;dict of controls to pulse options&gt;,
   tlist=&lt;time grid&gt;,
   kwargs...
)</code></pre><p>Note that the control problem can only be instantiated via keyword arguments.</p><p>The <code>objectives</code> are a list of <a href="#QuantumControlBase.AbstractControlObjective"><code>AbstractControlObjective</code></a> instances, each defining an initial state and a dynamical generator for the evolution of that state. Usually, the objective will also include a target state (see <a href="#QuantumControlBase.Objective"><code>Objective</code></a>) and possibly a weight (see <a href="#QuantumControlBase.WeightedObjective"><code>WeightedObjective</code></a>.</p><p>The <code>pulse_options</code> are a dictionary (<code>IdDict</code>) mapping controls that occur in the <code>objectives</code> to properties specific to the control method.</p><p>The <code>tlist</code> is the time grid on which the time evolution of the initial states of each objective should be propagated.</p><p>The remaining <code>kwargs</code> are keyword arguments that are passed directly to the optimal control method. These typically include e.g. the optimization functional.</p><p>The control problem is solved by finding a set of controls that simultaneously fulfill all objectives.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quantumcontrol-jl/QuantumControlBase.jl/blob/46bc29b4b57a47d47bf46d42af1235952fa890fb/src/controlproblem.jl#L68-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.Objective" href="#QuantumControlBase.Objective"><code>QuantumControlBase.Objective</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Standard optimization objective.</p><pre><code class="language-julia hljs">Objective(;
    initial_state=&lt;initial_state&gt;,
    generator=&lt;genenerator&gt;,
    target_state=&lt;target_state&gt;
)</code></pre><p>describes an optimization objective where the time evoluation of the given <code>initial_state</code> under the given <code>generator</code> aims towards <code>target_state</code>. The <code>generator</code> here is e.g. a time-dependent Hamiltonian or Liouvillian.</p><p>The most common control problems in quantum control, e.g. state-to-state transitions or quantum gate implementations can be expressed by simultaneously fulfilling multiple objectives of this type.</p><p>Note that the objective can only be instantiated via keyword arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quantumcontrol-jl/QuantumControlBase.jl/blob/46bc29b4b57a47d47bf46d42af1235952fa890fb/src/controlproblem.jl#L11-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.WeightedObjective" href="#QuantumControlBase.WeightedObjective"><code>QuantumControlBase.WeightedObjective</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Standard optimization objective with a weight.</p><pre><code class="language-julia hljs">WeightedObjective(;
    initial_state=&lt;initial_state&gt;,
    generator=&lt;genenerator&gt;,
    target_state=&lt;target_state&gt;,
    weight=&lt;weight&gt;
)</code></pre><p>initializes a control objective like <a href="#QuantumControlBase.Objective"><code>Objective</code></a>, but with an additional <code>weight</code> parameter (a float generally between 0 and 1) that weights the objective relative to other objectives that are part of the same control problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quantumcontrol-jl/QuantumControlBase.jl/blob/46bc29b4b57a47d47bf46d42af1235952fa890fb/src/controlproblem.jl#L41-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.adjoint-Tuple{Objective}" href="#Base.adjoint-Tuple{Objective}"><code>Base.adjoint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">adjoint(objective)</code></pre><p>Adjoint of a control objective. The adjoint objective contains the adjoint of the dynamical generator <code>obj.generator</code>, and adjoints of the <code>obj.initial_state</code> / <code>obj.target_state</code> if these exist and have an adjoint.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quantumcontrol-jl/QuantumControlBase.jl/blob/46bc29b4b57a47d47bf46d42af1235952fa890fb/src/controlproblem.jl#L130-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.blackman-Tuple{Any, Any, Any}" href="#QuantumControlBase.blackman-Tuple{Any, Any, Any}"><code>QuantumControlBase.blackman</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Blackman window shape.</p><pre><code class="language-julia hljs">blackman(t, t₀, T; a=0.16)</code></pre><p>calculates</p><p class="math-container">\[B(t; t_0, T) =
    \frac{1}{2}\left(
        1 - a - \cos\left(2π \frac{t - t_0}{T - t_0}\right)
        + a \cos\left(4π \frac{t - t_0}{T - t_0}\right)
    \right)\,,\]</p><p>for a scalar <code>t</code>, with <span>$a$</span> = 0.16.</p><p>See <a href="http://en.wikipedia.org/wiki/Window_function#Blackman_windows">http://en.wikipedia.org/wiki/Window_function#Blackman_windows</a></p><p>A Blackman shape looks nearly identical to a Gaussian with a 6-sigma interval between <code>t₀</code> and <code>T</code>.  Unlike the Gaussian, however, it will go exactly to zero at the edges. Thus, Blackman pulses are often preferable to Gaussians.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quantumcontrol-jl/QuantumControlBase.jl/blob/46bc29b4b57a47d47bf46d42af1235952fa890fb/src/shapes.jl#L73-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.box-Tuple{Any, Any, Any}" href="#QuantumControlBase.box-Tuple{Any, Any, Any}"><code>QuantumControlBase.box</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Box shape (Theta-function).</p><pre><code class="language-julia hljs">box(t, t₀, T)</code></pre><p>evaluates the Heaviside (Theta-) function <span>$\Theta(t) = 1$</span> for <span>$t_0 \le t \le T$</span>; and <span>$\Theta(t) = 0$</span> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quantumcontrol-jl/QuantumControlBase.jl/blob/46bc29b4b57a47d47bf46d42af1235952fa890fb/src/shapes.jl#L61-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.discretize-Tuple{Function, Any}" href="#QuantumControlBase.discretize-Tuple{Function, Any}"><code>QuantumControlBase.discretize</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Evaluate <code>control</code> at every point of <code>tlist</code>.</p><pre><code class="language-julia hljs">values = discretize(control, tlist; via_midpoints=true)</code></pre><p>discretizes the given <code>control</code> to a Vector of values defined on the points of <code>tlist</code>.</p><p>If <code>control</code> is a function, it will will first be evaluated at the midpoint of <code>tlist</code>, see <a href="#QuantumControlBase.discretize_on_midpoints-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:Function"><code>discretize_on_midpoints</code></a>, and then the values on the midpoints are converted to values on <code>tlist</code>. This discretization is more stable than directly evaluationg the control function at the values of <code>tlist</code>, and ensures that repeated round-trips between <a href="#QuantumControlBase.discretize-Tuple{Function, Any}"><code>discretize</code></a> and <a href="#QuantumControlBase.discretize_on_midpoints-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:Function"><code>discretize_on_midpoints</code></a> can be done safely, see the note in the documentation of <a href="#QuantumControlBase.discretize_on_midpoints-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:Function"><code>discretize_on_midpoints</code></a>.</p><p>The latter can still be achieved by passing <code>via_midpoints=false</code>. While such a direct discretization is suitable e.g. for plotting, but it is unsuitable for round-trips between <a href="#QuantumControlBase.discretize-Tuple{Function, Any}"><code>discretize</code></a> and <a href="#QuantumControlBase.discretize_on_midpoints-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:Function"><code>discretize_on_midpoints</code></a>  (constant controls on <code>tlist</code> may result in a zig-zag on the intervals of <code>tlist</code>).</p><p>If <code>control</code> is a vector, it will be returned un-modified if it is of the same length as <code>tlist</code>. Otherwise, <code>control</code> must have one less value than <code>tlist</code>, and is assumed to be defined on the midpoins of <code>tlist</code>. In that case, <a href="#QuantumControlBase.discretize-Tuple{Function, Any}"><code>discretize</code></a> acts as the inverse of <a href="#QuantumControlBase.discretize_on_midpoints-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:Function"><code>discretize_on_midpoints</code></a>. See <a href="#QuantumControlBase.discretize_on_midpoints-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:Function"><code>discretize_on_midpoints</code></a> for how control values on <code>tlist</code> and control values on the intervals of <code>tlist</code> are related.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quantumcontrol-jl/QuantumControlBase.jl/blob/46bc29b4b57a47d47bf46d42af1235952fa890fb/src/controls.jl#L1-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.discretize_on_midpoints-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:Function" href="#QuantumControlBase.discretize_on_midpoints-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:Function"><code>QuantumControlBase.discretize_on_midpoints</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Evaluate <code>control</code> at the midpoints of <code>tlist</code>.</p><pre><code class="nohighlight hljs">values = discretize_on_midpoints(control, tlist)</code></pre><p>discretizes the given <code>control</code> to a Vector of values on the midpoints of <code>tlist</code>. Hence, the resulting <code>values</code> will contain one less value than <code>tlist</code>.</p><p>If <code>control</code> is a vector of values defined on <code>tlist</code> (i.e., of the same length as <code>tlist</code>), it will be converted to a vector of values on the intervals of <code>tlist</code>. The value for the first and last &quot;midpoint&quot; will remain the original values at the beginning and end of <code>tlist</code>, in order to ensure exact bounary conditions. For all other midpoints, the value for that midpoint will be calculated by &quot;un-averaging&quot;.</p><p>For example, for a <code>control</code> and <code>tlist</code> of length 5, consider the following diagram:</p><pre><code class="nohighlight hljs">tlist index:       1   2   3   4   5
tlist:             ⋅   ⋅   ⋅   ⋅   ⋅   input values cᵢ (i ∈ 1..5)
                   |̂/ ̄ ̄ ̂\ / ̂\ / ̂ ̄ ̄\|̂
midpoints:         x     x   x     x   output values pᵢ (i ∈ 1..4)
midpoints index:   1     2   3     4</code></pre><p>We will have <span>$p₁=c₁$</span> for the first value, <span>$p₄=c₅$</span> for the last value. For all other points, the control values <span>$cᵢ = \frac{p_{i-1} + p_{i}}{2}$</span> are the average of the values on the midpoints. This implies the &quot;un-averaging&quot; for the midpoint values <span>$pᵢ = 2 c_{i} - p_{i-1}$</span>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>An arbitrary input <code>control</code> array may not be compatible with the above averaging formula. In this case, the conversion will be &quot;lossy&quot; (<a href="#QuantumControlBase.discretize-Tuple{Function, Any}"><code>discretize</code></a> will not recover the original <code>control</code> array; the difference should be considered a &quot;discretization error&quot;). However, any <em>further</em> round-trip conversions between points and intervals are bijective and preserve the boundary conditions. In this case, the <a href="#QuantumControlBase.discretize_on_midpoints-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:Function"><code>discretize_on_midpoints</code></a> and <a href="#QuantumControlBase.discretize-Tuple{Function, Any}"><code>discretize</code></a> methods are each other&#39;s inverse. This also implies that for an optimal control procedure, it is safe to modify <em>midpoint</em> values. Modifying the the values on the time grid directly on the other hand may accumulate discretization errors.</p></div></div><p>If <code>control</code> is a vector of one less length than <code>tlist</code>, it will be returned unchanged, under the assumption that the input is already properly discretized.</p><p>If <code>control</code> is a function, the function will be directly evaluated at the midpoints marked as <code>x</code> in the above diagram..</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quantumcontrol-jl/QuantumControlBase.jl/blob/46bc29b4b57a47d47bf46d42af1235952fa890fb/src/controls.jl#L61-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.flattop-Tuple{Any}" href="#QuantumControlBase.flattop-Tuple{Any}"><code>QuantumControlBase.flattop</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Flat shape (one) with a switch-on/switch-off from zero.</p><pre><code class="language-julia hljs">flattop(t; t₀, T, t_rise, t_fall=t_rise, func=:blackman)</code></pre><p>evaluates a shape function that starts at 0 at <span>$t=t₀$</span>, and ramps to to 1 during the <code>t_rise</code> interval. The function then remains at value 1, before ramping down to 0 again during the interval <code>t_fall</code> before <code>T</code>. For <span>$t &lt; t₀$</span> and <span>$t &gt; T$</span>, the shape is zero.</p><p>The default switch-on/-off shape is half of a Blackman window (see <a href="#QuantumControlBase.blackman-Tuple{Any, Any, Any}"><code>blackman</code></a>).</p><p>For <code>func=:sinsq</code>, the switch-on/-off shape is a sine-squared curve.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quantumcontrol-jl/QuantumControlBase.jl/blob/46bc29b4b57a47d47bf46d42af1235952fa890fb/src/shapes.jl#L4-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.getcontrols-Tuple{Tuple}" href="#QuantumControlBase.getcontrols-Tuple{Tuple}"><code>QuantumControlBase.getcontrols</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Extract a Tuple of controls.</p><pre><code class="language-julia hljs">controls = getcontrols(generator)</code></pre><p>extracts the controls from a single dynamical generator.</p><pre><code class="language-julia hljs">controls = getcontrols(objectives)</code></pre><p>extracts the controls from a list of objectives (i.e., from each objective&#39;s <code>generator</code>)</p><p>In either case, controls that occur multiple times, either in a single generator, or throughout the different objectives, will occur only once in the result.</p><p>By default, assumes that any <code>generator</code> is a nested Tuple, e.g. <code>(H0, (H1, ϵ1), (H2, ϵ2), ...)</code> and extracts (ϵ1, ϵ2)</p><p>Each control must be a valid argument for <code>discretize</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quantumcontrol-jl/QuantumControlBase.jl/blob/46bc29b4b57a47d47bf46d42af1235952fa890fb/src/controls.jl#L145-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.initobjpropwrk-Tuple{Objective, Any, Val}" href="#QuantumControlBase.initobjpropwrk-Tuple{Objective, Any, Val}"><code>QuantumControlBase.initobjpropwrk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wrk = initobjpropwrk(obj, tlist, method; kwargs...)</code></pre><p>initializes a workspace for the propagation of a control <a href="#QuantumControlBase.Objective"><code>Objective</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quantumcontrol-jl/QuantumControlBase.jl/blob/46bc29b4b57a47d47bf46d42af1235952fa890fb/src/propagate.jl#L74-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.liouvillian" href="#QuantumControlBase.liouvillian"><code>QuantumControlBase.liouvillian</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Construct a Liouvillian super-operator.</p><pre><code class="language-julia hljs">ℒ = liouvillian(Ĥ, c_ops=(); convention=:LvN)</code></pre><p>calculates the sparse Liouvillian super-operator <code>ℒ</code> from the Hamiltonian <code>Ĥ</code> and a list <code>c_ops</code> of Lindblad operators.</p><p>With <code>convention=:LvN</code>, applying the resulting <code>ℒ</code> to a vectorized density matrix <code>ρ⃗</code> calculates <span>$\frac{d}{dt} \vec{\rho}(t) = ℒ \vec{\rho}(t)$</span> equivalent to the Liouville-von-Neumann equation for the density matrix <span>$ρ̂$</span>,</p><p class="math-container">\[\frac{d}{dt} ρ̂(t)
= -i [Ĥ, ρ̂(t)] + \sum_k\left(
    Â_k ρ̂ Â_k^\dagger
    - \frac{1}{2} A_k^\dagger Â_k ρ̂
    - \frac{1}{2} ρ̂ Â_k^\dagger Â_k
  \right)\,,\]</p><p>where the Lindblad operators <span>$Â_k$</span> are the elements of <code>c_ops</code>.</p><p>The Hamiltonian <span>$Ĥ$</span> may be time-dependent, using a nested-tuple format by default, e.g., <code>(Ĥ₀, (H₁, ϵ₁), (H₂, ϵ₂))</code>, where <code>ϵ₁</code> and <code>ϵ₂</code> are functions of time. In this case, the resulting <code>ℒ</code> will also be in nested tuple format, <code>ℒ = (ℒ₀, (ℒ₁, ϵ₁), (ℒ₂, ϵ₂))</code>, where the initial element contains the superoperator <code>ℒ₀</code> for the static component of the Liouvillian, i.e., the commutator with the drift Hamiltonian <code>Ĥ₀</code>, plus the dissipator (sum over <span>$k$</span>), as a sparse matrix. Time-dependent Lindblad operators are not supported. The remaining elements are tuples <code>(ℒ₁, ϵ₁)</code> and <code>(ℒ₂, ϵ₂)</code> corresponding to the commutators with the two control Hamiltonians, where <code>ℒ₁</code> and <code>ℒ₂</code> again are sparse matrices.</p><p>If <span>$Ĥ$</span> is not time-dependent, the resulting <code>ℒ</code> will be a single-element tuple containing the Liouvillian as a sparse matrix, <code>ℒ = (ℒ₀, )</code>.</p><p>With <code>convention=:TDSE</code>, the Liouvillian will be constructed for the equation of motion <span>$-i \hbar \frac{d}{dt} \vec{\rho}(t) = ℒ \vec{\rho}(t)$</span> to match exactly the form of the time-dependent Schrödinger equation. While this notation is not standard in the literature of open quantum systems, it has the benefit that the resulting <code>ℒ</code> can be used in a numerical propagator for a (non-Hermitian) Schrödinger equation without any change. Thus, for numerical applications, <code>convention=:TDSE</code> is generally preferred. The returned <code>ℒ</code> between the two conventions differs only by a factor of <span>$i$</span>, since we generally assume <span>$\hbar=1$</span>.</p><p>The <code>convention</code> keyword argument is mandatory, to force a conscious choice.</p><p>See <a href="https://arxiv.org/abs/1312.0111v2">Goerz et. al. &quot;Optimal control theory for a unitary operation under dissipative evolution&quot;, arXiv 1312.0111v2, Appendix B.2</a> for the explicit construction of the Liouvillian superoperator as a sparse matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quantumcontrol-jl/QuantumControlBase.jl/blob/46bc29b4b57a47d47bf46d42af1235952fa890fb/src/liouvillian.jl#L61-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.setcontrolvals!-Union{Tuple{D}, Tuple{Any, Tuple, D}} where D&lt;:AbstractDict" href="#QuantumControlBase.setcontrolvals!-Union{Tuple{D}, Tuple{Any, Tuple, D}} where D&lt;:AbstractDict"><code>QuantumControlBase.setcontrolvals!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>In-place version of <a href="#QuantumControlBase.setcontrolvals-Union{Tuple{D}, Tuple{Tuple, D}} where D&lt;:AbstractDict"><code>setcontrolvals</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quantumcontrol-jl/QuantumControlBase.jl/blob/46bc29b4b57a47d47bf46d42af1235952fa890fb/src/controls.jl#L239">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.setcontrolvals-Union{Tuple{D}, Tuple{Tuple, D}} where D&lt;:AbstractDict" href="#QuantumControlBase.setcontrolvals-Union{Tuple{D}, Tuple{Tuple, D}} where D&lt;:AbstractDict"><code>QuantumControlBase.setcontrolvals</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct <code>G</code> by plugging values into a general generator.</p><pre><code class="language-julia hljs">G = setcontrolvals(generator, vals_dict)
setcontrolvals!(G, generator, vals_dict)</code></pre><p>evaluates the <em>specific</em> dynamical generator <code>G</code> by plugging in values into the general <code>generator</code> according to <code>vals_dict</code>.</p><p>The <code>vals_dict</code> is a dictionary (<code>IdDict</code>) mapping controls as returned by <code>getcontrols(generator)</code> to values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quantumcontrol-jl/QuantumControlBase.jl/blob/46bc29b4b57a47d47bf46d42af1235952fa890fb/src/controls.jl#L207-L220">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumPropagators.propagate-Tuple{Objective, Any}" href="#QuantumPropagators.propagate-Tuple{Objective, Any}"><code>QuantumPropagators.propagate</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Propagate the initial state of a control objective.</p><pre><code class="language-julia hljs">propagate(obj, tlist; method=:auto, controls_map=IdDict(), kwargs...)</code></pre><p>propagates <code>obj.initial_state</code> under the dynamics described by <code>obj.generator</code>.</p><p>The optional dict <code>control_map</code> may be given to replace the controls in <code>obj.generator</code> (as obtained by <a href="#QuantumControlBase.getcontrols-Tuple{Tuple}"><code>getcontrols</code></a>) with custom functions or vectors, e.g. with the controls resulting from optimization.</p><p>All other <code>kwargs</code> are forwarded to the underlying <code>propagate</code> method for <code>obj.initial_state</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quantumcontrol-jl/QuantumControlBase.jl/blob/46bc29b4b57a47d47bf46d42af1235952fa890fb/src/propagate.jl#L6-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlBase.ConditionalThreads.@threadsif-Tuple{Any, Any}" href="#QuantumControlBase.ConditionalThreads.@threadsif-Tuple{Any, Any}"><code>QuantumControlBase.ConditionalThreads.@threadsif</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Conditionally apply multi-threading to <code>for</code> loops.</p><p>This is a variation on <code>Base.Threads.@threads</code> that adds a run-time boolean flag to enable or disable threading. It is intended for <em>internal use</em> in packages building on <code>QuantumControlBase</code>.</p><p>Usage:</p><pre><code class="language-julia hljs">using QuantumControlBase.ConditionalThreads: @threadsif

function optimize(objectives; use_threads=true)
    @threadsif use_threads for k = 1:length(objectives)
    # ...
    end
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quantumcontrol-jl/QuantumControlBase.jl/blob/46bc29b4b57a47d47bf46d42af1235952fa890fb/src/conditionalthreads.jl#L6-L24">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.6 on <span class="colophon-date" title="Sunday 12 September 2021 04:15">Sunday 12 September 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
